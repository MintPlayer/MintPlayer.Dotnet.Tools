# PRD: InjectSourceGenerator Base Dependency Forwarding

## Problem Statement

The current `InjectSourceGenerator` only generates constructors for classes that have:
- At least one `[Inject]`-marked field or property, OR
- A `[PostConstruct]` method

However, when a partial class extends another class that requires constructor parameters, the derived class needs a constructor to forward those parameters. This applies to two scenarios:

1. **Base class with `[Inject]` fields** - The generator creates a constructor for the base class, and derived classes need to call it
2. **Base class with a manually-written constructor** - The base class has an explicit constructor requiring parameters

In both cases, if the derived class has **neither** `[Inject]` fields **nor** `[PostConstruct]` methods, no constructor is generated, causing a compilation error.

### Scenario 1: Base class with [Inject] fields

```csharp
public partial class BaseClass
{
    [Inject] private readonly IService _service;

    // Generated: public BaseClass(IService service) { this._service = service; }
}

public partial class DerivedClass : BaseClass
{
    // No [Inject] fields, no [PostConstruct]
    // PROBLEM: No constructor generated
    // RESULT: Compilation error CS7036 - cannot call base constructor
}
```

### Scenario 2: Base class with manual constructor

```csharp
public partial class BaseClass
{
    private readonly IService _service;

    // Manually written constructor
    public BaseClass(IService service)
    {
        this._service = service;
    }
}

public partial class DerivedClass : BaseClass
{
    // No [Inject] fields, no [PostConstruct]
    // PROBLEM: No constructor generated
    // RESULT: Compilation error CS7036 - cannot call base constructor
}
```

### Expected Behavior (Both Scenarios)

Both scenarios should be handled identically - the generator should detect that the base class constructor requires parameters and generate a forwarding constructor:

```csharp
// Generated for DerivedClass (same output for both scenarios)
partial class DerivedClass
{
    public DerivedClass(IService service)
        : base(service)
    {
    }
}
```

## Requirements

### Functional Requirements

1. **FR1: Generate constructors for partial classes with base constructor parameters**
   - When a partial class extends a class whose constructor requires parameters
   - This includes BOTH:
     - Base classes with `[Inject]` members (constructor generated by this generator)
     - Base classes with manually-written constructors requiring parameters
   - Generate a constructor that accepts all required parameters and forwards them to the base constructor

2. **FR2: Uniform handling of both scenarios**
   - The generator should treat both scenarios identically
   - Detection should be based on the base class constructor signature, not on how it was created

3. **FR3: Maintain backward compatibility**
   - Existing behavior for classes with `[Inject]` fields must remain unchanged
   - Classes that don't extend classes requiring constructor parameters should not be affected

4. **FR4: Support multi-level inheritance**
   - If `A` requires constructor params, `B : A` has none, and `C : B` has none
   - Both `B` and `C` should get generated constructors forwarding parameters
   - Works regardless of whether `A`'s constructor is generated or manual

5. **FR5: Only apply to partial classes**
   - Non-partial classes cannot have generated code added
   - Only generate constructors for classes marked as `partial`

6. **FR6: Support PostConstruct in derived classes**
   - If a derived class has a `[PostConstruct]` method
   - The generated constructor should call the PostConstruct method after the base call

### Non-Functional Requirements

1. **NFR1: Incremental generator performance**
   - Use efficient filtering to avoid processing unrelated classes
   - Leverage existing `SyntaxProvider` patterns

2. **NFR2: Clear diagnostics**
   - If a non-partial class extends a class requiring constructor forwarding, emit a warning

## Technical Design

### Detection Logic

The generator needs to detect base class constructor parameters from two sources:

1. **`[Inject]` members in base classes** (existing logic)
   - Traverse inheritance hierarchy
   - Collect fields/properties marked with `[Inject]`

2. **Base class constructor parameters** (new logic)
   - Get the base class's constructor(s)
   - Extract parameter types and names from constructors requiring parameters
   - Use this information when no `[Inject]` members are found

### Code Generation Condition

Generate a constructor when ANY of these conditions are met:
- `InjectFields.Count > 0` (class has its own `[Inject]` members)
- `BaseDependencies.Count > 0` (base class has `[Inject]` members)
- `BaseConstructorParameters.Count > 0` (base class has constructor with parameters)

### Data Model Changes

The `ClassWithBaseDependenciesAndInjectFields` model needs to capture:
- `BaseDependencies` - inherited `[Inject]` dependencies from base classes
- `BaseConstructorParameters` - parameters from base class constructor (when no `[Inject]` found)
- `InjectFields` - dependencies from current class

### Generated Code Examples

**Example 1: Base with [Inject], derived with nothing**
```csharp
// Input
public partial class BaseService
{
    [Inject] private readonly ILogger _logger;
}

public partial class DerivedService : BaseService
{
    // No [Inject] fields
}

// Generated for BaseService
partial class BaseService
{
    public BaseService(global::ILogger logger)
    {
        this._logger = logger;
    }
}

// Generated for DerivedService
partial class DerivedService
{
    public DerivedService(global::ILogger logger)
        : base(logger)
    {
    }
}
```

**Example 2: Base with manual constructor, derived with nothing**
```csharp
// Input
public partial class BaseService
{
    private readonly ILogger _logger;

    public BaseService(ILogger logger)  // Manual constructor
    {
        this._logger = logger;
    }
}

public partial class DerivedService : BaseService
{
    // No [Inject] fields
}

// Generated for DerivedService (same as Example 1!)
partial class DerivedService
{
    public DerivedService(global::ILogger logger)
        : base(logger)
    {
    }
}
```

**Example 3: Multi-level with manual constructor at root**
```csharp
// Input
public partial class RootService
{
    private readonly ILogger _logger;

    public RootService(ILogger logger)  // Manual constructor
    {
        this._logger = logger;
    }
}

public partial class MiddleService : RootService
{
    // No constructor, no [Inject]
}

public partial class LeafService : MiddleService
{
    // No constructor, no [Inject]
}

// Generated for MiddleService
partial class MiddleService
{
    public MiddleService(global::ILogger logger)
        : base(logger)
    {
    }
}

// Generated for LeafService
partial class LeafService
{
    public LeafService(global::ILogger logger)
        : base(logger)
    {
    }
}
```

**Example 4: Mixed - manual constructor base, [Inject] in leaf**
```csharp
// Input
public partial class BaseService
{
    private readonly ILogger _logger;

    public BaseService(ILogger logger)  // Manual constructor
    {
        this._logger = logger;
    }
}

public partial class DerivedService : BaseService
{
    [Inject] private readonly IRepository _repository;
}

// Generated for DerivedService
partial class DerivedService
{
    public DerivedService(global::IRepository repository, global::ILogger logger)
        : base(logger)
    {
        this._repository = repository;
    }
}
```

## Test Cases

### Unit Tests (MintPlayer.SourceGenerators.Debug)

1. **TC1: Base with [Inject], derived with nothing**
   - Base class with `[Inject]` field
   - Derived partial class with no `[Inject]` fields
   - Verify constructor is generated with base call

2. **TC2: Base with manual constructor, derived with nothing**
   - Base class with manually-written constructor requiring parameters
   - Derived partial class with no `[Inject]` fields
   - Verify constructor is generated with base call (same as TC1)

3. **TC3: Multi-level inheritance with [Inject] at root**
   - Three-level hierarchy where only the root has `[Inject]`
   - Verify all derived classes get appropriate constructors

4. **TC4: Multi-level inheritance with manual constructor at root**
   - Three-level hierarchy where only the root has manual constructor
   - Verify all derived classes get appropriate constructors (same as TC3)

5. **TC5: Derived class with PostConstruct only**
   - Base has constructor (either type), derived has only `[PostConstruct]`
   - Verify PostConstruct is called in generated constructor

6. **TC6: Mixed scenario - manual base, [Inject] in derived**
   - Base has manual constructor, derived has `[Inject]` fields
   - Verify derived gets constructor with both own fields and base params

7. **TC7: No constructor needed**
   - Inheritance tree where base class has parameterless constructor
   - Verify NO constructors are generated for derived classes

## Out of Scope

- Handling multiple constructors in base class (use primary/first constructor)
- Supporting optional parameters in base constructors
- Modifying existing constructor overloads or adding additional overloads

## Success Criteria

1. All test cases pass
2. Existing tests continue to pass (backward compatibility)
3. Generated code compiles and runs correctly
4. Both scenarios (generated and manual base constructors) produce identical derived constructors
5. No performance regression in generator execution time

## Implementation Plan

1. Create test cases demonstrating both scenarios
2. Update data model to include `BaseConstructorParameters`
3. Modify `InjectSourceGenerator.cs` to detect base constructor parameters
4. Update generation condition to include base constructor parameters
5. Verify all tests pass
6. Update documentation
