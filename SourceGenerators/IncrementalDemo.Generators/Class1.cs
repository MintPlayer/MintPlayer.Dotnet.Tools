using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
//using Newtonsoft.Json;
//using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;

namespace IncrementalDemo.Generators;

[Generator(LanguageNames.CSharp)]
public class ClassNamesSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var config = context.AnalyzerConfigOptionsProvider
            .Select(static (p, ct) =>
            {
                p.GlobalOptions.TryGetValue("build_property.rootnamespace", out var rootNamespace);
                return new Settings
                {
                    RootNamespace = rootNamespace,
                };
            })
            .WithComparer(SettingsValueComparer.Instance);

        var classNamesProvider = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, ct) =>
            {
                return node is ClassDeclarationSyntax { } classDeclaration;
            },
            static (context, ct) =>
            {
                if (context.Node is ClassDeclarationSyntax classDeclaration &&
                    context.SemanticModel.GetDeclaredSymbol(classDeclaration, ct) is INamedTypeSymbol symbol)
                {
                    return new ClassDeclaration { Name = symbol.Name };
                }
                else
                {
                    return default;
                }
            }
        );

        var classNamesSourceProvider = classNamesProvider
            .WithComparer(ClassDeclarationValueComparer.Instance)
            // Group whatever you want
            .Collect()

            .Combine(config)
            // only call once
            .Select(static (p, ct) => new ClassNamesProducer(declarations: p.Left, rootNamespace: p.Right.RootNamespace!));

        // Combine all Source Providers
        var sourceProvider = classNamesSourceProvider;

        // Generate Code
        context.RegisterSourceOutput(sourceProvider, static (c, g) => g?.Generate(c));
    }
}

public class ClassNamesProducer : IncrementalProducer
{
    private readonly IEnumerable<ClassDeclaration> declarations;
    public ClassNamesProducer(IEnumerable<ClassDeclaration> declarations, string rootNamespace) : base(rootNamespace)
    {
        this.declarations = declarations;
    }

    protected override (string? FileName, string? Source) ProduceSource(CancellationToken cancellationToken)
    {
        var source = new StringBuilder();
        source.AppendLine(Header);
        source.AppendLine();
        source.AppendLine($"namespace {RootNamespace};");

        source.AppendLine("public static class ClassNames");
        source.AppendLine("{");
        var list = string.Join(", ", declarations.Select(d => $"\"{d.Name}\""));
        source.AppendLine($"    public static string[] List => [{list}];");
        source.AppendLine("}");

        var sourceText = source.ToString();
        var fileName = $"ClassNames.g.cs";

        return (fileName, sourceText);
    }
}

public abstract class IncrementalProducer
{
    protected IncrementalProducer(string rootNamespace)
    {
        RootNamespace = rootNamespace;
    }

    public const string Header = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //    This code was generated from source generator.
        //
        //    Manual changes to this file may cause unexpected behavior in your application.
        //    Manual changes to this file will be overwritten if the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        """;

    protected abstract (string? FileName, string? Source) ProduceSource(CancellationToken cancellationToken);

    public string? RootNamespace { get; }

    public void Generate(SourceProductionContext context)
    {
        context.CancellationToken.ThrowIfCancellationRequested();
        var source = ProduceSource(context.CancellationToken);
        if (source is { FileName: not null, Source: not null } generatedSource)
        {
            context.AddSource(generatedSource.FileName, SourceText.From(source.Source, Encoding.UTF8));
        }
    }
}

[ValueComparer(typeof(SettingsValueComparer))]
public sealed class Settings
{
    public string? RootNamespace { get; set; }
}

[ValueComparer(typeof(ClassDeclarationValueComparer))]
public class ClassDeclaration
{
    public string? Name { get; set; }
}

public class ClassDeclarationValueComparer : ValueComparer<ClassDeclaration>
{
    protected override bool AreEqual(ClassDeclaration x, ClassDeclaration y)
    {
        if (!IsEquals(x.Name, y.Name)) return false;

        return true;
    }
}

/// <summary>
/// Abstract base Value Comparer class
/// </summary>
public abstract class ValueComparer<T> : IEqualityComparer<T?>
{
    public static IEqualityComparer<T?> Instance { get; } = ValueComparers.GetComparer<T>();

    public static bool IsEquals<TValue>(TValue? x, TValue? y) => ValueComparers.GetComparer<TValue>().Equals(x, y);

    protected abstract bool AreEqual(T x, T y);

    public bool Equals(T? x, T? y)
    {
        if (x is null && y is null) // Note: When both are null then Value Equals
            return true;

        if (x is null ^ y is null) // Note: When one of the 2 is null then Value Unequals
            return false;

        return AreEqual(x!, y!); // Note: When both are not null
    }

    public virtual int GetHashCode(T? obj) => throw new NotImplementedException();
}

public sealed class SettingsValueComparer : ValueComparer<Settings>
{
    protected override bool AreEqual(Settings x, Settings y)
    {
        if (!IsEquals(x.RootNamespace, y.RootNamespace))
            return false;

        return true;
    }
}

/// <summary>
/// Helper class for <see cref="ValueComparer{T}"/>.
/// </summary>
public static class ValueComparers
{
    private static class Cache<TValue>
    {
        public static IEqualityComparer<TValue?> Comparer { get; }

        static Cache()
        {
            // Note: Add Comparer when it is not possible via ValueCompareAttribute
            // Note: ImmutableArrays cannot be casted to IEqualityComparer<TValue?>?, therefore use AsEnumerable() to cast it to IEnumerable<TValue?>?.
            // Note: ImmutableDictionary does not contain order, therefore we cannot use it.

            var underlyingType = Nullable.GetUnderlyingType(typeof(TValue));

            var type = underlyingType ?? typeof(TValue);

            var arg1 = type.IsGenericType ? type.GetGenericArguments().ElementAtOrDefault(0) : null;
            var arg2 = type.IsGenericType ? type.GetGenericArguments().ElementAtOrDefault(1) : null;
            var arg3 = type.IsGenericType ? type.GetGenericArguments().ElementAtOrDefault(2) : null;
            var arg4 = type.IsGenericType ? type.GetGenericArguments().ElementAtOrDefault(3) : null;

            var comparerType = type switch
            {
                // Collection Comparers
                { IsArray: true } => typeof(ArrayValueComparer<>).MakeGenericType(type.GetElementType()!),
                { IsGenericType: true } when type.GetGenericTypeDefinition() == typeof(List<>) => typeof(ListValueComparer<>).MakeGenericType(arg1 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when type.GetGenericTypeDefinition() == typeof(IEnumerable<>) => typeof(IEnumerableValueComparer<>).MakeGenericType(arg1 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when type.GetGenericTypeDefinition() == typeof(IReadOnlyCollection<>) => typeof(IReadOnlyCollectionValueComparer<>).MakeGenericType(arg1 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when type.GetGenericTypeDefinition() == typeof(Dictionary<,>) => typeof(DictionaryValueComparer<,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException()),

                // Value Pairs Comparers
                { IsGenericType: true } when underlyingType is null && type.GetGenericTypeDefinition() == typeof(ValueTuple<,>) => typeof(ValueTupleValueComparer<,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is null && type.GetGenericTypeDefinition() == typeof(ValueTuple<,,>) => typeof(ValueTupleValueComparer<,,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException(), arg3 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is null && type.GetGenericTypeDefinition() == typeof(ValueTuple<,,,>) => typeof(ValueTupleValueComparer<,,,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException(), arg3 ?? throw new InvalidOperationException(), arg4 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is null && type.GetGenericTypeDefinition() == typeof(KeyValuePair<,>) => typeof(KeyValuePairValueComparer<,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is not null && type.GetGenericTypeDefinition() == typeof(ValueTuple<,>) => typeof(NullableValueTupleValueComparer<,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is not null && type.GetGenericTypeDefinition() == typeof(ValueTuple<,,>) => typeof(NullableValueTupleValueComparer<,,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException(), arg3 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is not null && type.GetGenericTypeDefinition() == typeof(ValueTuple<,,,>) => typeof(NullableValueTupleValueComparer<,,,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException(), arg3 ?? throw new InvalidOperationException(), arg4 ?? throw new InvalidOperationException()),
                { IsGenericType: true } when underlyingType is not null && type.GetGenericTypeDefinition() == typeof(KeyValuePair<,>) => typeof(NullableKeyValuePairValueComparer<,>).MakeGenericType(arg1 ?? throw new InvalidOperationException(), arg2 ?? throw new InvalidOperationException()),

                // Object Comparers
                //{ } jObjectType when jObjectType == typeof(JObject) => typeof(JObjectValueComparer),
                { } locationType when locationType == typeof(Location) => typeof(LocationValueComparer),

                // Default Value Comparers
                { } stringType when stringType == typeof(string) => typeof(DefaultValueComparer<>).MakeGenericType(type),
                { IsPrimitive: true } => typeof(DefaultValueComparer<>).MakeGenericType(type),
                { IsEnum: true } => typeof(DefaultValueComparer<>).MakeGenericType(type),
                { IsValueType: true } => typeof(DefaultValueComparer<>).MakeGenericType(typeof(TValue)),

                // Attribute Value Comparer
                _ => type.GetCustomAttribute<ValueComparerAttribute>()?.ComparerType,
            };

            Comparer = (IEqualityComparer<TValue?>?)Activator.CreateInstance(comparerType ?? throw new InvalidOperationException()) ?? throw new NotImplementedException();
        }
    }

    public static IEqualityComparer<TValue?> GetComparer<TValue>() => Cache<TValue>.Comparer;
}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public sealed class ValueComparerAttribute : Attribute
{
    public Type ComparerType { get; }

    public ValueComparerAttribute(Type comparerType)
    {
        if (!comparerType.IsDerivedFrom(typeof(ValueComparer<>)))
            throw new ArgumentException($"Argument 'comparerType' must be derived type from ValueComparer<>", nameof(comparerType));

        ComparerType = comparerType;
    }
}

/// <summary>
/// Value Comparer for Array types
/// </summary>
public sealed class ArrayValueComparer<TValue> : ValueComparer<TValue[]>
{
    protected override bool AreEqual(TValue[] x, TValue[] y)
    {
        if (!IsEquals(x.Length, y.Length))
            return false;

        // ReSharper disable once LoopCanBeConvertedToQuery
        for (var i = 0; i < x.Length; i++)
        {
            if (!IsEquals(x[i], y[i]))
                return false;
        }

        return true;
    }
}

/// <summary>
/// Value Comparer for Array types
/// </summary>
public sealed class IEnumerableValueComparer<TValue> : ValueComparer<IEnumerable<TValue>>
{
    protected override bool AreEqual(IEnumerable<TValue> x, IEnumerable<TValue> y)
    {
        using var enumX = x.GetEnumerator();
        using var enumY = y.GetEnumerator();

        while (true)
        {
            bool moveNextX = enumX.MoveNext();
            bool moveNextY = enumY.MoveNext();

            if (moveNextX != moveNextY)
                return false;

            if (!moveNextX)
                return true;

            if (!IsEquals(enumX.Current, enumY.Current))
                return false;
        }
    }
}

/// <summary>
/// Value Comparer for IReadOnlyCollection types
/// </summary>
public sealed class IReadOnlyCollectionValueComparer<TValue> : ValueComparer<IReadOnlyCollection<TValue>>
{
    protected override bool AreEqual(IReadOnlyCollection<TValue> x, IReadOnlyCollection<TValue> y)
    {
        if (!IsEquals(x.Count, y.Count))
            return false;

        using var enumX = x.GetEnumerator();
        using var enumY = y.GetEnumerator();

        while (true)
        {
            bool moveNextX = enumX.MoveNext();
            bool moveNextY = enumY.MoveNext();

            if (moveNextX != moveNextY)
                return false;

            if (!moveNextX)
                return true;

            if (!IsEquals(enumX.Current, enumY.Current))
                return false;
        }
    }
}

public class LocationValueComparer : ValueComparer<Location>
{
    protected override bool AreEqual(Location x, Location y)
    {
        return x.Equals(y);
    }
}

/// <summary>
/// Value Comparer for Dictionary types
/// </summary>
public sealed class DictionaryValueComparer<TKey, TValue> : ValueComparer<Dictionary<TKey, TValue>>
{
    protected override bool AreEqual(Dictionary<TKey, TValue> x, Dictionary<TKey, TValue> y)
    {
        if (!IsEquals(x.Count, y.Count))
            return false;

        if (x.Keys.Except(y.Keys).Any())
            return false;

        if (y.Keys.Except(x.Keys).Any())
            return false;

        foreach (var item in x)
        {
            if (!IsEquals(item.Value, y[item.Key]))
                return false;
        }

        return true;
    }
}

/// <summary>
/// Value Comparer for KeyValuePair types
/// </summary>
public sealed class KeyValuePairValueComparer<TKey, TValue> : ValueComparer<KeyValuePair<TKey, TValue>>
{
    protected override bool AreEqual(KeyValuePair<TKey, TValue> x, KeyValuePair<TKey, TValue> y)
    {
        if (!IsEquals(x.Key, y.Key))
            return false;

        if (!IsEquals(x.Value, y.Value))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for KeyValuePair types
/// </summary>
public sealed class NullableKeyValuePairValueComparer<TKey, TValue> : ValueComparer<KeyValuePair<TKey, TValue>?>
{
    protected override bool AreEqual(KeyValuePair<TKey, TValue>? x, KeyValuePair<TKey, TValue>? y)
    {
        if (!IsEquals(x!.Value.Key, y!.Value.Key))
            return false;

        if (!IsEquals(x!.Value.Value, y!.Value.Value))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for List types
/// </summary>
public sealed class ListValueComparer<TValue> : ValueComparer<List<TValue>>
{
    protected override bool AreEqual(List<TValue> x, List<TValue> y)
    {
        if (!IsEquals(x.Count, y.Count))
            return false;

        // ReSharper disable once LoopCanBeConvertedToQuery
        for (var i = 0; i < x.Count; i++)
        {
            if (!IsEquals(x[i], y[i]))
                return false;
        }

        return true;
    }
}

///// <summary>
///// Value Comparer for JObject types
///// </summary>
//public sealed class JObjectValueComparer : ValueComparer<JObject>
//{
//    protected override bool AreEqual(JObject x, JObject y)
//    {
//        return IsEquals(x.ToString(Formatting.None), y.ToString(Formatting.None));
//    }
//}


public static class TypeExtensions
{
    public static bool IsDerivedFrom(this Type type, Type baseType)
    {
        while (type != null && type != typeof(object))
        {
            var cur = type.IsGenericType ? type.GetGenericTypeDefinition() : type;

            if (baseType == cur)
                return true;

            type = type.BaseType!;
        }

        return false;
    }
}


/// <summary>
/// Value Comparer for ValueTuple types
/// </summary>
public sealed class ValueTupleValueComparer<T1, T2> : ValueComparer<(T1, T2)>
{
    protected override bool AreEqual((T1, T2) x, (T1, T2) y)
    {
        if (!IsEquals(x.Item1, y.Item1))
            return false;

        if (!IsEquals(x.Item2, y.Item2))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for ValueTuple types
/// </summary>
public sealed class ValueTupleValueComparer<T1, T2, T3> : ValueComparer<(T1, T2, T3)>
{
    protected override bool AreEqual((T1, T2, T3) x, (T1, T2, T3) y)
    {
        if (!IsEquals(x.Item1, y.Item1))
            return false;

        if (!IsEquals(x.Item2, y.Item2))
            return false;

        if (!IsEquals(x.Item3, y.Item3))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for ValueTuple types
/// </summary>
public sealed class ValueTupleValueComparer<T1, T2, T3, T4> : ValueComparer<(T1, T2, T3, T4)>
{
    protected override bool AreEqual((T1, T2, T3, T4) x, (T1, T2, T3, T4) y)
    {
        if (!IsEquals(x.Item1, y.Item1))
            return false;

        if (!IsEquals(x.Item2, y.Item2))
            return false;

        if (!IsEquals(x.Item3, y.Item3))
            return false;

        if (!IsEquals(x.Item4, y.Item4))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for ValueTuple types
/// </summary>
public sealed class NullableValueTupleValueComparer<T1, T2> : ValueComparer<(T1, T2)?>
{
    protected override bool AreEqual((T1, T2)? x, (T1, T2)? y)
    {
        if (!IsEquals(x!.Value.Item1, y!.Value.Item1))
            return false;

        if (!IsEquals(x!.Value.Item2, y!.Value.Item2))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for ValueTuple types
/// </summary>
public sealed class NullableValueTupleValueComparer<T1, T2, T3> : ValueComparer<(T1, T2, T3)?>
{
    protected override bool AreEqual((T1, T2, T3)? x, (T1, T2, T3)? y)
    {
        if (!IsEquals(x!.Value.Item1, y!.Value.Item1))
            return false;

        if (!IsEquals(x!.Value.Item2, y!.Value.Item2))
            return false;

        if (!IsEquals(x!.Value.Item3, y!.Value.Item3))
            return false;

        return true;
    }
}

/// <summary>
/// Value Comparer for ValueTuple types
/// </summary>
public sealed class NullableValueTupleValueComparer<T1, T2, T3, T4> : ValueComparer<(T1, T2, T3, T4)?>
{
    protected override bool AreEqual((T1, T2, T3, T4)? x, (T1, T2, T3, T4)? y)
    {
        if (!IsEquals(x!.Value.Item1, y!.Value.Item1))
            return false;

        if (!IsEquals(x!.Value.Item2, y!.Value.Item2))
            return false;

        if (!IsEquals(x!.Value.Item3, y!.Value.Item3))
            return false;

        if (!IsEquals(x!.Value.Item4, y!.Value.Item4))
            return false;

        return true;
    }
}

/// <summary>
/// Default Value Comparer
/// </summary>
public sealed class DefaultValueComparer<T> : ValueComparer<T>
{
    protected override bool AreEqual(T x, T y)
    {
        return EqualityComparer<T>.Default.Equals(x, y);
    }
}
